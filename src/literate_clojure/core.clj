;;; This file is automatically generated from file `src/literate_clojure/core.org'.
;;; It is not designed to be readable by a human.
;;; It is generated to load by clojure directly without depending on `literate-clojure'.
;;; Please read file `src/literate_clojure/core.org' to find out the usage and implementation detail of this source file.

(ns literate-clojure.core
  (:require
    [clojure.pprint :refer [cl-format]]
    [clojure.string :refer [starts-with? lower-case trim split]]
    [clojure.tools.reader.reader-types :as reader-types]
    [clojure.tools.reader])
  (:import (clojure.lang LispReader LispReader$WrappingReader)))

(defonce ^:dynamic debug-p nil)

(defn debug [& args]
  (when debug-p
    (apply println "literate-clojure: " args)))

(def ^:dynamic tools-reader-p nil)

(defn read-char [reader]
  (if tools-reader-p
    (let [c (reader-types/read-char reader)]
      (if c
        (int c)
        -1))
    (.read reader)))

(defn- line-terminator? [c]
  (or (= c (int \return)) (= c (int \newline))))

(defn- literate-read-line [reader]
  (let [c (read-char reader)]
    (cond (= c -1) nil
          (line-terminator? c) ""
          :else (with-out-str
                  (do (cl-format *out* "~c" (char c))
                      (loop [c (read-char reader)]
                        (when (and (not= c -1)
                                   (not (line-terminator? c)))
                          (cl-format *out* "~c" (char c))
                          (recur (read-char reader)))))))))

(defn- dispatch-reader-macro [ch fun]
  (let [dm (.get (doto (.getDeclaredField clojure.lang.LispReader "dispatchMacros")
                   (.setAccessible true))
                 nil)]
    (when (nil? (aget dm (int ch)))
      (debug (cl-format nil "install dispatch reader macro for character '~a'" ch))
      (aset dm (int ch) fun))))

(def load-tags
  (distinct (concat (if-let [tags (System/getenv "LITERATE_LOAD_TAGS")]
                      (split tags #","))
                    (if-let [tags (System/getProperty "literate-clojure.load.tags")]
                      (split tags #",")))))

(defn- load? [arguments]
  (debug (cl-format nil "header arguments is: ~s" arguments))
  (loop [left-arguments arguments]
    (cond (empty? left-arguments) true
          (= (first left-arguments) ":load") (let [load-tag (second left-arguments)]
                                               (cond (empty? load-tag) true
                                                     (= "yes" load-tag) true
                                                     (= "no" load-tag) nil
                                                     (some #(= % load-tag) load-tags) true))

          :else (if-let [left-arguments (next left-arguments)]
                  (recur left-arguments)))))

(def id-of-begin-src "#+begin_src")
(def literate-begin-src-ids (for [lang '("clojure" "clojurescript")]
                              (format "%s %s" id-of-begin-src lang)))
(defn- read-org-code-block-header-arguments [line]
  (let [trimmed-line (trim line)]
    ;; remove two head tokens.
    (rest (rest (split (lower-case trimmed-line) #"\s+")))))

(defn- dispatch-sharp-space [reader quote opts pending-forms]
  (debug "enter into org syntax.")
  (loop [line (literate-read-line reader)]
    (cond (nil? line) (debug "reach end of stream in org syntax.")
          (some #(starts-with? (format "%s " (lower-case (trim line))) (format "%s " %)) literate-begin-src-ids)
          (do (debug "reach begin of code block.")
              (if (load? (read-org-code-block-header-arguments line))
                  (debug "enter into clojure syntax.")
                (recur (literate-read-line reader))))
          :else (do
                  (debug (cl-format nil "ignore line: ~a" line))
                  (recur (literate-read-line reader)))))
  reader)
(defn- tools-reader-dispatch-sharp-space [reader quote opts pending-forms]
  (binding [tools-reader-p true]
    (dispatch-sharp-space reader quote opts pending-forms)))

(defn- dispatch-sharp-plus [reader quote opts pending-forms]
  (let [line (literate-read-line reader)]
    (cond (nil? line) (debug "reach end of stream in org syntax.")
          (starts-with? (lower-case (trim line)) "end_src")
          (do (debug "reach begin of code block.")
              (debug "switch back from clojure syntax to org syntax.")
              (dispatch-sharp-space reader quote opts pending-forms))
          :else (throw (Exception. (cl-format nil "invalid syntax in line :~a" line))))))
(defn- tools-reader-dispatch-sharp-plus [reader quote opts pending-forms]
  (binding [tools-reader-p true]
    (dispatch-sharp-plus reader quote opts pending-forms)))

(defn install-org-dispatcher [& args]
  (when-not args
    (dispatch-reader-macro \+ dispatch-sharp-plus)
    (dispatch-reader-macro \space dispatch-sharp-space)))
(println "install literate syntax to clojure reader.")
(install-org-dispatcher)

(defn tools.reader.additional-dispatch-macros [orig-fn]
  #(or (orig-fn %)
       (case %
         \+ tools-reader-dispatch-sharp-plus
         \space tools-reader-dispatch-sharp-space
         nil)))
(println "install literate syntax to tools.reader.")
(alter-var-root (var clojure.tools.reader/dispatch-macros) #'tools.reader.additional-dispatch-macros)

(def exception-id-of-end-of-stream "end-of-litereate-stream")
(defn tangle-file
  ([org-file]
   (tangle-file org-file (cl-format nil ";;; This file is automatically generated from file `~a'.
;;; It is not designed to be readable by a human.
;;; It is generated to load by clojure directly without depending on `literate-clojure'.
;;; Please read file `~a' to find out the usage and implementation detail of this source file.~%~%"
                                    org-file org-file)))
  
  ([org-file header]
   (tangle-file org-file header
                (str (.substring org-file 0 (.lastIndexOf org-file "."))
                     ".clj")))
  ([org-file header clj-file]
   (with-open [reader (clojure.lang.LineNumberingPushbackReader. (clojure.java.io/reader org-file))]
     (with-open [writer (clojure.java.io/writer clj-file)]
       (.write writer header)
       (try
         (while true
           ;; ignore all lines of org syntax.
           (dispatch-sharp-space reader \space nil nil)
           ;; start to read clojure codes.
           (loop [line (literate-read-line reader)]
             (cond (nil? line) (do (debug "reach end of stream in org syntax.")
                                   (throw (Exception. exception-id-of-end-of-stream)))
                   (starts-with? (lower-case (trim line)) "#+end_src")
                   (debug "reach end of code block.")
                   :else (do
                           (debug (cl-format nil "tangle line: ~a" line))
                           (.write writer line)
                           (.write writer "\n")
                           (recur (literate-read-line reader)))))
           (.write writer "\n")
           (.flush writer))
         (catch Exception e
           (if (not= exception-id-of-end-of-stream (.getMessage e))
             ;; we don't know about this exception, throw it again.
             (throw e))))))))

